# 尊享面试100题

## 624. [数组列表中的最大距离](./leetcode/editor/cn/MaximumDistanceInArrays.java)

### 暴力解法

由于所有数组内的数是已经经过排列的了，所以我们只需要比较两个相邻数组的第一位和最后一位就行（两次）。

时间复杂度n<sup>2</sup>

### 单次扫描（贪心）

维护整体的min_val和max_val，将它们初始化为第一个数组的极值。创建res储存结果并初始化为0。

遍历一遍从第二个数组开始，计算该数组的最大值与min_val的差值、该数组的最小值与max_val的差值，取res和这些结果的最大值，并更新min_val和max_val。

总而言之，min_val和max_val都是对于所有数组来说的最大最小值，检查每个数组时去与当前的最大最小来比较就可以得出结果。

#### QA

Q: 如果最大和最小同时在一个数组中会发生什么？

A: max_val和min_val在使用时是处理之前的数组时记录的，并不会影响结果

## 280. [摆动排序](./leetcode/editor/cn/WiggleSort.java)

### 暴力解法

将数组排序后，每两位之间互换即可

### 贪心算法

假设有数组[0],[1],[2],[3],[4]...

遍历数组，若[0]>[1]，则将[0]和[1]互换（相反则满足条件，不动）

此时[0]<[1]，继续下一位[2]

若[1]<[2]，互换[1]和[2]（因为[0]<[1]，所以在互换后仍满足[0]<[2])

此时[0]<=[2]>=[1]，继续下一位[3]

若[1]>[3]，互换[1]和[3]（因为[2]>[1]，所以在互换后仍满足[2]>[3])

此时[0]<[2]>[3]<[1]

以此类推...

总结规律，则当i为偶数位时，判断[i+1]是否大于[i]，是则互换

则当i为奇数位时，判断[i+1]是否小于[i]，是则互换

## 1056. [易混淆数](./leetcode/editor/cn/ConfusingNumber.java)

由于倒转后的值是顺序变为逆序的，所以用纯数学方法储存结果需要知道数值的位数，并不方便。所以在此处使用StringBuilder创建字符串来储存结果。

创建数值的副本，每次通过取余来获得最后一位数，上下倒转后append到StringBuilder中，并将副本减去该值。例如：

number=8196, res="0"

第一次处理后：number=819, res="06"

第二次处理后：number=81, res="061"

以此类推，并最终使用`Integer.parseInt`转化为整数，开头的0会自动去除

## 1427. [字符串的左右移](./leetcode/editor/cn/PerformStringShifts.java)

首先以整数形式计算最终的移动方向和步数，存于`finalShift`中

`finalShift`取余以省略超出字符串长度的移动步数

当`finalShift`为负，即向左移动时，加上字符串长度即可转换为向右移动的步数

以`finalShift`为切点，以后半部分+前半部分的形式返回结果
